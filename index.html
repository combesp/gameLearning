<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Sons magiques ğŸ¦„ â€” Lecture des sons complexes</title>
  <style>
    /* 
      ==========================================
      PINK FAIRYTALE THEME (mobile-first)
      ==========================================
      - Big tappable targets
      - High contrast on text inside buttons
      - Pastel pink gradient + subtle animated stars
      - Decorative emoji stickers: ğŸ¦„ğŸ§šâ€â™€ï¸ğŸ‘‘ğŸŒˆ (Unicode â€” no license required)
    */

    :root{
      --bg1: #ffe3f1;
      --bg2: #ffd1e8;
      --accent: #ff5fa2;
      --accent-2:#f74c8f;
      --accent-3:#ff99c8;
      --ink: #5b2b41;
      --ok: #1aa05d;
      --bad:#d93050;
      --card:#ffffffee;
      --shadow: 0 10px 30px rgba(219, 77, 118, .25);
    }

    html, body{
      height: 100%;
      margin: 0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
      color: var(--ink);
      background: radial-gradient(1200px 800px at 20% -10%, #fff6fb 0%, var(--bg1) 40%, var(--bg2) 100%);
      overflow-x: hidden;
    }

    .stars{ /* subtle animated glitter */
      pointer-events: none;
      position: fixed; inset: 0; z-index: 0;
      background:
        radial-gradient(2px 2px at 10% 20%, rgba(255,255,255,.7), transparent 40%),
        radial-gradient(2px 2px at 30% 80%, rgba(255,255,255,.5), transparent 40%),
        radial-gradient(2px 2px at 70% 30%, rgba(255,255,255,.6), transparent 40%),
        radial-gradient(2px 2px at 85% 60%, rgba(255,255,255,.5), transparent 40%);
      animation: twinkle 6s linear infinite;
    }
    @keyframes twinkle { from{ filter: brightness(1);} 50%{ filter: brightness(1.3);} to{ filter: brightness(1);} }

    header{
      z-index: 2;
      position: sticky; top: 0; 
      padding: 12px clamp(12px, 3vw, 32px);
      display: flex; align-items: center; gap: 12px; justify-content: space-between;
      backdrop-filter: blur(6px);
    }
    .brand{
      display:flex; align-items:center; gap:12px; font-weight: 800; letter-spacing:.2px;
      color: var(--accent-2);
    }
    .brand .sticker{font-size: 28px;}

    .shell{
      z-index:1; position: relative;
      margin: 0 auto; max-width: 980px; padding: 12px clamp(12px, 3vw, 28px) 80px;
    }

    .panel{
      background: var(--card); border-radius: 18px; box-shadow: var(--shadow);
      padding: clamp(12px, 2.5vw, 20px);
    }

    .toolbar{ display:flex; flex-wrap: wrap; gap: 10px; align-items: center; justify-content: space-between; }

    .row{ display:flex; flex-wrap: wrap; gap: 10px; align-items: center; }

    .chip{ border: 2px solid var(--accent-3); color: var(--ink); padding:8px 12px; border-radius: 999px; background:#fff; }

    .btn{
      -webkit-tap-highlight-color: transparent; user-select: none;
      border: 0; border-radius: 14px; padding: 14px 18px; font-weight: 700; 
      background: linear-gradient(180deg, var(--accent), var(--accent-2)); color: #fff;
      box-shadow: 0 6px 0 #c13a71, 0 12px 22px rgba(240, 80, 140, .3);
      transform: translateY(0);
      transition: transform .08s ease, box-shadow .2s ease, filter .2s ease;
      cursor: pointer;
    }
    .btn:hover{ filter: brightness(1.05); }
    .btn:active{ transform: translateY(2px); box-shadow: 0 4px 0 #c13a71, 0 8px 18px rgba(240, 80, 140, .35); }

    .btn-ghost{ background:#fff; color: var(--accent-2); border:2px solid var(--accent-3); box-shadow:none; }

    .game{
      display:grid; gap: 16px; margin-top: 16px;
      grid-template-columns: 1fr; align-items: start;
    }

    .hud{ display:flex; flex-wrap: wrap; gap: 8px; align-items: center; justify-content: space-between; }
    .stat{ background:#fff; border:1px solid #ffd0e6; border-radius: 12px; padding:8px 10px; font-weight: 700; }

    .timer{
      --t: 10;
      position: relative; width: 120px; height: 12px; border-radius:999px; overflow: hidden; background:#ffd6eb; border:1px solid #ffc1de;
    }
    .timer > i{ position:absolute; inset:0; background: linear-gradient(90deg,#b2f7ef,#cfd2ff,#ffc6ff,#ffd6a5); width: calc(var(--p,100) * 1%); transition: width .2s linear; }

    .prompt{
      display:flex; align-items:center; justify-content:center; gap:8px; 
      font-size: clamp(18px, 4vw, 22px); font-weight: 800; color: var(--accent-2);
      background: #fff; border: 2px dashed #ffc1de; padding: 12px; border-radius: 16px;
    }

    .options{
      display:grid; gap: 12px; grid-template-columns: repeat(2, minmax(0, 1fr));
    }

    .opt{
      -webkit-tap-highlight-color: transparent;
      border: 0; border-radius: 16px; padding: clamp(18px, 4vw, 26px);
      background:#fff; border:2px solid #ffd0e6; box-shadow: var(--shadow);
      font-size: clamp(24px, 5vw, 30px); font-weight: 900; color: var(--ink);
      cursor: pointer; transition: transform .08s ease, background .2s ease, border-color .2s ease, box-shadow .2s ease;
    }
    .opt:hover{ transform: translateY(-1px); }
    .opt:active{ transform: translateY(1px); }
    .opt.correct{ outline: none; border-color: #9be7c4; background:#f0fff7; }
    .opt.wrong{ outline: none; border-color: #ffb3c1; background:#fff0f3; }

    .feedback{ min-height: 28px; font-weight: 800; }
    .feedback.ok{ color: var(--ok); }
    .feedback.bad{ color: var(--bad); }

    .levelbar{ height: 10px; background:#ffe6f3; border:1px solid #ffd0e6; border-radius:999px; overflow:hidden; }
    .levelbar > i{ display:block; height:100%; width:0%; background: linear-gradient(90deg, #ff9ecb, #ff69b4); transition: width .3s ease; }

    .stickers{ display:flex; gap: 8px; flex-wrap: wrap; font-size: 22px; opacity:.9; }

    .footer-note{ font-size: 12px; opacity:.8; margin-top: 12px; }

    /* Confetti canvas is full-screen but pointer-events:none */
    #confetti{ position: fixed; inset:0; z-index: 10; pointer-events: none; }

    /* Utility */
    .hide{ display:none !important; }
  </style>
</head>
<body>
  <div class="stars" aria-hidden="true"></div>
  <canvas id="confetti" aria-hidden="true"></canvas>

  <header>
    <div class="brand">
      <span class="sticker" aria-hidden="true">ğŸ¦„</span>
      <span>Sons magiques â€” lecture des sons</span>
    </div>
    <div class="stickers" aria-hidden="true">ğŸ§šâ€â™€ï¸ ğŸ‘‘ ğŸŒˆ ğŸ¦„</div>
  </header>

  <main class="shell">
    <section class="panel toolbar" aria-label="RÃ©glages">
      <div class="row">
        <button class="btn" id="startBtn">â–¶ï¸ Commencer</button>
        <button class="btn btn-ghost" id="replayBtn" title="RÃ©pÃ©ter le son">ğŸ”Š RÃ©pÃ©ter</button>
        <button class="btn btn-ghost" id="muteBtn" title="Activer/DÃ©sactiver la voix">ğŸ”ˆ Muet</button>
      </div>
      <div class="row" role="group" aria-label="DurÃ©e du chrono">
        <span class="chip">â±ï¸ Chrono:</span>
        <label class="chip"><input type="radio" name="timer" value="5"> 5s</label>
        <label class="chip"><input type="radio" name="timer" value="10" checked> 10s</label>
        <label class="chip"><input type="radio" name="timer" value="20"> 20s</label>
        <label class="chip"><input type="radio" name="timer" value="30"> 30s</label>
      </div>
      <div class="row" role="group" aria-label="Affichage du son">
        <label class="chip"><input type="checkbox" id="showSoundToggle"> Afficher le son Ã  l'Ã©cran</label>
      </div>
    </section>

    <section class="panel game" aria-live="polite">
      <div class="hud">
        <div class="stat">Score: <span id="score">0</span></div>
        <div class="stat">SÃ©rie: <span id="streak">0</span></div>
        <div class="stat">PrÃ©cision: <span id="accuracy">0%</span></div>
        <div class="stat">Niveau: <span id="levelLabel">4 sons</span></div>
        <div class="timer" id="timer" aria-label="Temps restant"><i></i></div>
      </div>

      <div class="prompt" id="prompt">
        <span aria-hidden="true">ğŸ§šâ€â™€ï¸</span>
        <span id="promptText">Clique sur â–¶ï¸ Commencer et Ã©coute le son...</span>
      </div>

      <div class="options" id="options">
        <!-- option buttons dynamically injected -->
      </div>

      <div id="feedback" class="feedback"></div>

      <div>
        <div class="levelbar" title="Progression du niveau (sons actifs)"><i id="levelProgress"></i></div>
        <div class="footer-note">ThÃ¨me: rose fÃ©Ã©rique (licornes ğŸ¦„, fÃ©es ğŸ§šâ€â™€ï¸, princesses ğŸ‘‘, arcs-en-ciel ğŸŒˆ). Voix: Web Speech API fr-FR (si disponible). Aucune donnÃ©e n'est envoyÃ©e â€” tout se passe dans le navigateur.</div>
      </div>
    </section>
  </main>

  <script>
    /* =============================================================
       MAGICAL SOUNDS â€” Reading Practice Game
       -------------------------------------------------------------
       â€¢ Single-file HTML/CSS/JS (works on desktop & mobile)
       â€¢ Web Speech API (TTS) to announce the sound in French
       â€¢ 4 big options per round, click/tap the correct grapheme
       â€¢ Timer with selectable duration (5/10/20/30 seconds)
       â€¢ Speed-based scoring + streak bonus
       â€¢ Encouraging feedback; confetti on success
       â€¢ Leitner (5 boxes) spaced repetition within the session
       â€¢ Progressive difficulty: starts with [on, ou, an, ai], then
         unlocks one new sound every 5 correct answers
       â€¢ Clean, commented code (English) for maintainability
       ============================================================= */

    // ---------- Data: graphemes and their "phoneme family" ----------
    // Family is used to avoid offering equivalent graphemes together
    // in the same question (e.g., an/en belong to the same nasal sound).
    const SOUNDS_ORDERED = [
      // Initial set (level 1)
      { g: 'on', fam: 'on' },
      { g: 'ou', fam: 'ou' },
      { g: 'an', fam: 'an' },
      { g: 'ai', fam: 'ai' },
      // Progressive unlocks (each added later)
      { g: 'oi', fam: 'oi' },
      { g: 'au', fam: 'au' },
      { g: 'eu', fam: 'eu' },
      { g: 'ch', fam: 'ch' },
      { g: 'gn', fam: 'gn' },
      { g: 'ill', fam: 'ill' },
      { g: 'ph', fam: 'ph' }, // pronounced /f/
      { g: 'ui', fam: 'ui' },
      { g: 'oin', fam: 'oin' },
      { g: 'ion', fam: 'ion' },
      { g: 'ien', fam: 'ien' },
      { g: 'in', fam: 'in' },
      { g: 'ain', fam: 'in' },
      { g: 'ein', fam: 'in' },
      { g: 'en', fam: 'an' },
      { g: 'am', fam: 'an' },
      { g: 'em', fam: 'an' },
      { g: 'un', fam: 'un' },
      { g: 'um', fam: 'un' },
      { g: 'eau', fam: 'au' },
      { g: 'Å“u', fam: 'eu' },
    ];

    // How to pronounce each grapheme with TTS (French). Some are adjusted
    // so the synthetic voice says the intended sound (e.g., "ill" -> "ille").
    const PRONOUNCE = {
      'ill': 'ille',
      'ph': 'f',
      'Å“u': 'eu',
      // default: use grapheme itself
    };

    // Encouragement/correction messages (French kid-friendly)
    const PRAISE = [
      'Bravo ! ğŸ¦„âœ¨', 'Super ! ğŸ‘‘', 'GÃ©nial ! ğŸŒˆ', 'Magnifique ! ğŸ§šâ€â™€ï¸', 'Tu es un champion ! ğŸ’«'
    ];
    const ENCOURAGE = [
      'Presque ! On rÃ©essaie ! ğŸ’ª', 'Pas grave, tu vas y arriver ! ğŸŒŸ', 'Courage, tu progresses ! ğŸ¦„', 'On continue, tu es fort ! ğŸ‘‘'
    ];

    // Leitner box intervals in *questions*, randomized in range for variety
    const BOX_INTERVALS = {
      1: [1, 2],   // show again very soon
      2: [3, 5],
      3: [7, 12],
      4: [15, 24],
      5: [28, 40], // fairly spaced
    };

    // Game state (in-memory only â€” no persistence in v1)
    const state = {
      activeCount: 4,              // starts with 4 sounds (on, ou, an, ai)
      correctSinceUnlock: 0,       // every 5 correct answers unlocks 1 new sound
      deck: [],                    // array of Card objects
      questionIndex: 0,            // counts asked questions to compute due
      current: null,               // current Card
      lastTargetG: null,           // avoid same target twice in a row
      timerTotal: 10 * 1000,       // ms (default 10s)
      timerLeft: 0,
      timerTick: null,
      score: 0,
      asked: 0,
      right: 0,
      streak: 0,
      muted: false,
      showingSoundOnScreen: false,
    };

    // Card object factory
    function makeCard({ g, fam }){
      return {
        g, fam,
        box: 1,
        dueAt: 0,        // next question index when this card is due
        stats: { asked: 0, correct: 0 },
      };
    }

    // Initialize deck with the first N sounds
    function initDeck(){
      state.deck = SOUNDS_ORDERED.slice(0, state.activeCount).map(makeCard);
      state.correctSinceUnlock = 0;
      state.questionIndex = 0;
      state.current = null;
      state.lastTargetG = null;
      state.score = 0; state.asked = 0; state.right = 0; state.streak = 0;
      updateHUD();
    }

    // Unlock one additional sound (if available)
    function unlockNext(){
      if(state.activeCount >= SOUNDS_ORDERED.length) return false;
      const next = SOUNDS_ORDERED[state.activeCount];
      state.deck.push(makeCard(next));
      state.activeCount += 1;
      state.correctSinceUnlock = 0;
      pulseLevelBar();
      return true;
    }

    // Utility: random int in [a, b]
    const rnd = (a,b)=> Math.floor(Math.random()*(b-a+1))+a;

    // Schedule next dueAt based on Leitner box
    function schedule(card){
      const [minQ, maxQ] = BOX_INTERVALS[card.box] || [3,6];
      const offset = rnd(minQ, maxQ);
      card.dueAt = state.questionIndex + offset;
    }

    // Choose next target card (prefer those due; if none, pick closest
    // and prefer lower box numbers so "weak" items show up more often)
    function pickNextCard(){
      // candidates: due or closest
      const due = state.deck.filter(c => c.dueAt <= state.questionIndex);
      if(due.length){
        // Prefer lowest box among due, avoid same as last target
        due.sort((a,b)=> a.box - b.box || a.dueAt - b.dueAt);
        const choices = due.filter(c=> c.g !== state.lastTargetG);
        return (choices[0] || due[0]);
      }
      // Otherwise, pick the soonest due; tie-breaker lower box
      const soonest = [...state.deck].sort((a,b)=> (a.dueAt - b.dueAt) || (a.box - b.box));
      const choices = soonest.filter(c=> c.g !== state.lastTargetG);
      return (choices[0] || soonest[0]);
    }

    // Build 3 distractors from other families (to avoid ambiguous pairs)
    function buildOptions(target){
      const pool = state.deck.filter(c => c.g !== target.g && c.fam !== target.fam);
      // If pool has less than 3 (early levels), take from full catalog excluding same family
      let extra = [];
      if(pool.length < 3){
        extra = SOUNDS_ORDERED
          .filter(s => s.g !== target.g && s.fam !== target.fam && !state.deck.some(c => c.g === s.g));
      }
      const totalPool = [...pool, ...extra];
      // Pick 3 unique distractors with distinct families
      const distractors = [];
      const famUsed = new Set([target.fam]);
      while(distractors.length < 3 && totalPool.length){
        const i = rnd(0, totalPool.length - 1);
        const pick = totalPool.splice(i,1)[0];
        if(!famUsed.has(pick.fam)){
          distractors.push(pick);
          famUsed.add(pick.fam);
        }
      }
      // In the very unlikely case we still have <3 (extremely early), backfill from anything not same g
      while(distractors.length < 3){
        const any = SOUNDS_ORDERED[rnd(0, SOUNDS_ORDERED.length-1)];
        if(any.g !== target.g && !distractors.some(d=>d.g===any.g)) distractors.push(any);
      }
      // Assemble and shuffle
      const options = [target.g, ...distractors.map(d=>d.g)];
      for(let i=options.length-1; i>0; i--){
        const j = Math.floor(Math.random()*(i+1));
        [options[i], options[j]] = [options[j], options[i]];
      }
      return options;
    }

    // Speak the sound using Web Speech API in fr-FR
    function speak(grapheme){
      if(state.muted) return;
      const text = PRONOUNCE[grapheme] || grapheme;
      if('speechSynthesis' in window){
        window.speechSynthesis.cancel();
        const u = new SpeechSynthesisUtterance(text);
        u.lang = 'fr-FR';
        u.rate = 0.9; // slightly slower for clarity
        u.pitch = 1.0;
        window.speechSynthesis.speak(u);
      }
    }

    // Optionally speak encouragement/correction
    function speakShort(text){
      if(state.muted) return;
      if('speechSynthesis' in window){
        const u = new SpeechSynthesisUtterance(text);
        u.lang = 'fr-FR'; u.rate = 1.0; u.pitch = 1.0;
        window.speechSynthesis.speak(u);
      }
    }

    // Render HUD (score, streak, accuracy, level, timer bar)
    function updateHUD(){
      document.getElementById('score').textContent = state.score;
      document.getElementById('streak').textContent = state.streak;
      const acc = state.asked ? Math.round((state.right/state.asked)*100) : 0;
      document.getElementById('accuracy').textContent = acc + '%';
      document.getElementById('levelLabel').textContent = state.activeCount + ' sons';
      // Level progress is fraction of sounds unlocked vs total
      const pct = Math.round((state.activeCount / SOUNDS_ORDERED.length) * 100);
      document.getElementById('levelProgress').style.width = pct + '%';
    }

    // Visual pulse on level bar when unlocking a new sound
    function pulseLevelBar(){
      const bar = document.getElementById('levelProgress');
      bar.animate([
        { transform: 'scaleY(1)' },
        { transform: 'scaleY(1.8)' },
        { transform: 'scaleY(1)' },
      ], { duration: 600, easing: 'ease-out' });
      updateHUD();
    }

    // Start timer per question
    function startTimer(){
      clearInterval(state.timerTick);
      state.timerLeft = state.timerTotal;
      setTimerBar(100);
      const startedAt = performance.now();
      state.timerTick = setInterval(()=>{
        const elapsed = performance.now() - startedAt;
        state.timerLeft = Math.max(0, state.timerTotal - elapsed);
        const p = Math.max(0, Math.round((state.timerLeft / state.timerTotal) * 100));
        setTimerBar(p);
        if(state.timerLeft <= 0){
          clearInterval(state.timerTick);
          timesUp();
        }
      }, 100);
    }

    function setTimerBar(pct){
      const t = document.querySelector('#timer i');
      t.style.width = pct + '%';
      // Optionally animate hue as time decreases (subtle)
      t.style.filter = `hue-rotate(${(100-pct)*2}deg)`;
    }

    // Handle timeout as incorrect answer
    function timesUp(){
      lockOptions();
      showFeedback(false, `Temps Ã©coulÃ© â° â€” la bonne rÃ©ponse Ã©tait â€œ${state.current.g}â€.`);
      // Reset card to box 1 and reschedule soon
      state.current.box = 1; schedule(state.current);
      state.streak = 0;
      state.asked++;
      updateHUD();
      // Next question after a short pause
      setTimeout(nextQuestion, 1400);
    }

    // Render a question round
    function renderQuestion(){
      const prompt = document.getElementById('promptText');
      const optionsEl = document.getElementById('options');
      optionsEl.innerHTML = '';

      // Prompt text (may hide actual grapheme if toggle off)
      prompt.textContent = state.showingSoundOnScreen ? `Quel est le son â€œ${state.current.g}â€ ?` : 'Ã‰coute et choisis le bon sonâ€¦';

      // Build option buttons
      const opts = buildOptions(state.current);
      for(const g of opts){
        const b = document.createElement('button');
        b.className = 'opt'; b.textContent = g; b.dataset.g = g;
        b.addEventListener('click', onAnswerClick, { passive: true });
        optionsEl.appendChild(b);
      }

      // Speak the target sound
      speak(state.current.g);

      // Start the timer now that everything is ready
      startTimer();

      // Clear feedback
      const fb = document.getElementById('feedback');
      fb.className = 'feedback'; fb.textContent = '';
    }

    function onAnswerClick(ev){
      const chosen = ev.currentTarget.dataset.g;
      lockOptions();
      clearInterval(state.timerTick);

      // Mark buttons
      document.querySelectorAll('.opt').forEach(btn=>{
        if(btn.dataset.g === state.current.g) btn.classList.add('correct');
        if(btn.dataset.g === chosen && chosen !== state.current.g) btn.classList.add('wrong');
      });

      // Update stats and deck scheduling (Leitner)
      const timeFrac = Math.max(0, Math.min(1, state.timerLeft / state.timerTotal));
      const base = 100; const speedBonus = Math.round(100 * timeFrac);
      let gained = 0;

      state.current.stats.asked++;
      state.asked++;

      if(chosen === state.current.g){
        state.current.stats.correct++;
        state.right++;
        state.streak++;
        // Move up a box, reschedule later
        state.current.box = Math.min(5, state.current.box + 1);
        schedule(state.current);

        // Scoring: base + speed bonus, streak multiplier (max +30%)
        const streakMult = 1 + Math.min(0.30, state.streak * 0.05);
        gained = Math.round((base + speedBonus) * streakMult);
        state.score += gained;

        // Feedback + confetti
        showFeedback(true, PRAISE[rnd(0, PRAISE.length-1)] + ` +${gained} pts`);
        celebrate();
        speakShort('Bravo !');

        // Unlock progression: every 5 correct answers â†’ +1 sound
        state.correctSinceUnlock++;
        if(state.correctSinceUnlock >= 5){
          const did = unlockNext();
          if(did){ showFeedback(true, 'âœ¨ Nouveau son dÃ©bloquÃ© !'); }
        }
      } else {
        // Wrong: send back to box 1, reschedule soon
        state.streak = 0;
        state.current.box = 1; schedule(state.current);
        const penalty = 20; state.score = Math.max(0, state.score - penalty);
        showFeedback(false, ENCOURAGE[rnd(0, ENCOURAGE.length-1)] + `  (Bonne rÃ©ponseÂ : â€œ${state.current.g}â€)`);
        speakShort('On rÃ©essaie !');
      }

      updateHUD();
      // Proceed after a short pause to let child see feedback
      setTimeout(nextQuestion, 1200);
    }

    function lockOptions(){
      document.querySelectorAll('.opt').forEach(b=> b.disabled = true);
    }

    function showFeedback(ok, text){
      const el = document.getElementById('feedback');
      el.className = 'feedback ' + (ok ? 'ok' : 'bad');
      el.textContent = text;
    }

    // Confetti animation (tiny, no dependency)
    function celebrate(){
      const cvs = document.getElementById('confetti');
      const ctx = cvs.getContext('2d');
      const W = cvs.width = window.innerWidth; const H = cvs.height = window.innerHeight;
      const pieces = Array.from({length: 80}, ()=>({
        x: Math.random()*W,
        y: -20 - Math.random()*H*0.2,
        s: 4 + Math.random()*6,
        vy: 2 + Math.random()*3,
        vx: -1 + Math.random()*2,
        rot: Math.random()*Math.PI,
        vr: -0.2 + Math.random()*0.4,
      }));
      let alive = true;
      const t0 = performance.now();
      function step(){
        ctx.clearRect(0,0,W,H);
        for(const p of pieces){
          p.x += p.vx; p.y += p.vy; p.rot += p.vr;
          ctx.save();
          ctx.translate(p.x, p.y); ctx.rotate(p.rot);
          ctx.fillStyle = ['#ff69b4','#ffd166','#06d6a0','#118ab2','#ef476f'][p.s % 5];
          ctx.fillRect(-p.s/2, -p.s/2, p.s, p.s*0.6);
          ctx.restore();
        }
        if(performance.now() - t0 < 1100){ requestAnimationFrame(step); }
        else { ctx.clearRect(0,0,W,H); alive = false; }
      }
      step();
      // auto-clean (safety)
      setTimeout(()=>{ if(alive){ ctx.clearRect(0,0,W,H); } }, 1400);
    }

    // Create a new round
    function nextQuestion(){
      state.questionIndex++;
      // Pick next due card; if deck empty (shouldn't happen), re-init
      const card = pickNextCard();
      state.current = card; state.lastTargetG = card.g;
      renderQuestion();
    }

    // ---------------------- UI bindings -------------------------
    const startBtn = document.getElementById('startBtn');
    const replayBtn = document.getElementById('replayBtn');
    const muteBtn = document.getElementById('muteBtn');

    startBtn.addEventListener('click', ()=>{
      // Ensure voices are allowed on iOS by starting after a user gesture
      initDeck();
      nextQuestion();
    }, { passive: true });

    replayBtn.addEventListener('click', ()=>{
      if(state.current) speak(state.current.g);
    }, { passive: true });

    muteBtn.addEventListener('click', ()=>{
      state.muted = !state.muted;
      muteBtn.textContent = state.muted ? 'ğŸ”‡ Son off' : 'ğŸ”ˆ Muet';
      if(state.muted && 'speechSynthesis' in window) window.speechSynthesis.cancel();
    }, { passive: true });

    document.querySelectorAll('input[name="timer"]').forEach(r=>{
      r.addEventListener('change', ()=>{
        const v = parseInt(r.value, 10);
        if(r.checked){ state.timerTotal = v * 1000; }
      }, { passive: true });
    });

    document.getElementById('showSoundToggle').addEventListener('change', (e)=>{
      state.showingSoundOnScreen = !!e.currentTarget.checked;
      // If a question is on-screen, update prompt text immediately
      if(state.current){
        const prompt = document.getElementById('promptText');
        prompt.textContent = state.showingSoundOnScreen ? `Quel est le son â€œ${state.current.g}â€ ?` : 'Ã‰coute et choisis le bon sonâ€¦';
      }
    }, { passive: true });

    // Accessibility: replay sound with keyboard "R"
    window.addEventListener('keydown', (e)=>{
      if(e.key.toLowerCase() === 'r'){ if(state.current) speak(state.current.g); }
    });

    // On resize, update confetti canvas size if it exists
    window.addEventListener('resize', ()=>{
      const cvs = document.getElementById('confetti');
      if(cvs){ cvs.width = window.innerWidth; cvs.height = window.innerHeight; }
    });

    // Gentle reminder if Web Speech API missing
    if(!('speechSynthesis' in window)){
      const fb = document.getElementById('feedback');
      fb.className = 'feedback bad';
      fb.textContent = 'âš ï¸ La synthÃ¨se vocale n\'est pas disponible sur ce navigateur. Le jeu reste jouable, mais sans voix.';
    }
  </script>
</body>
</html>
